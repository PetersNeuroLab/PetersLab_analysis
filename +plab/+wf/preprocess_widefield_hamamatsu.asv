function [U,Vrec,im_avg,frame_info] = preprocess_widefield_hamamatsu(im_files,n_frames_rec)
%
% TO DO: THIS NEEDS A LOT OF CLEANING UP DEPENDING ON WHAT FILE TYPES WE
% END UP GOING WITH
%
% [U,Vrec,im_color_avg,frame_info] = preprocess_widefield_hamamatsu(im_files)
%
% SVD-compress widefield imaging from Hamamatsu ORCA-Flash 4.0 v3
% Assumes: 
% - alternating 2-color imaging that resets order on recording start
% - recordings are defined by timestamp gaps of >2s
%
% Input -- 
% im_path: path containing widefield images as TIFFs
%
% Outputs -- 
% U: SVD spatial components (by color)
% Vrec: SVD temporal components split by recording (recording x color)
% im_avg: average raw image (by color)
% frame_info: header information for each frame 

%%%%%%%%%%%%%     TEMPORARY: getting bin files working
data_fn = "D:\LocalData\test\2023-06-01\widefield\widefield_1632_data.bin";
metadata_fn = "D:\LocalData\test\2023-06-01\widefield\widefield_1632_metadata.bin";

data_fid = fopen(data_fn,'r');
metadata_fid = fopen(metadata_fn,'r');

% Metadata format: [image height, image width, frame number, timestamp
% (year,month,day,hour,minute,second)]
widefield_metadata = reshape(fread(metadata_fid,'double'),9,[]);

im_size = unique(widefield_metadata(1:2,:));
if length(im_size) ~= 2
    error('Widefield: not uniform image size')
end

%%%%%%%%%%%%%%%%%


%%%%%% TEMPORARY: big try/catch for debug

try

verbose = true; % Turn off messages by default

%% Set maximum number of components to keep

max_components = 2000;

%% Get image filetype

[~,~,im_ext] = fileparts(im_files{1});
switch im_ext
    case '.dcimg'
        im_filetype = 'dcimg';
    case '.tif'
        im_filetype = 'tif';
    otherwise
        error('Widefield preprocessing: unrecognized image filetype');
end

%% Get header information from all frames

switch im_filetype

    case 'tif'
    % Tiff files: get header information from metadata

    if verbose; disp('Getting image headers...'); end

    % Loop through all files, get frame number and timestamp

    for curr_im_idx = 1:length(im_files)
        file_info = imfinfo(im_files{curr_im_idx});

        % get file metadata
        file_md = {file_info.ImageDescription};

        % using the first one, save out the information for the whole recording
        frame_md = file_md{1};

        % find indexes for the title and the content
        all_title_beg_idx = strfind(frame_md, '[');
        all_title_end_idx = strfind(frame_md, ']');
        all_section_beg_idx = all_title_end_idx+1;
        all_section_end_idx = [all_section_beg_idx(2:end)-1, length(frame_md)];

        % go through each section and pull content
        for n_section=1:length(all_section_beg_idx)-1 % exclude the last section

            % get section title and get rid of extra characters
            title = frame_md(all_title_beg_idx(n_section):all_title_end_idx(n_section));
            title = lower(strrep(erase(title,{'[ ', ' ]'}),' ', '_'));

            % get section contents
            section_str = frame_md(all_section_beg_idx(n_section):all_section_end_idx(n_section));

            % split by .. = ..
            name_pattern = '(?<name>(\w+).*?)';
            values_pattern = '(?<value>.*?(\w+).*?\n)';
            expr = [name_pattern ' = ' values_pattern];
            test = regexp(section_str, expr, 'names');

            % save in frame_info
            for val_idx=1:length(test)
                name = strrep(test(val_idx).name,' ', '_');
                value = test(val_idx).value;
                frame_info(curr_im_idx).(title).(name) = value(1:end-2);
            end
        end

        % get timestamp
        timestamp_section = frame_md(1:all_title_beg_idx(1)-1);
        expr = '\d*.[a-z]+.\d*.\d*:\d*:\d*';
        timestamp_str = regexpi(timestamp_section, expr, 'match');
        frame_info(curr_im_idx).timestamp = repmat(datetime(timestamp_str,...
            'InputFormat','dd MMM yyyy HH:mm:ss', ...
            'Format', 'yyyy-MMM-dd HH:mm:ss.SSSS'), ...
            1, length(file_info));

        % get times for all frames
        name_pattern = '(?<name>Time_From_+(Start|Last))';
        time_pattern = '(?<time>\d\d:\d\d:\d\d.\d\d\d\d)';
        expr = [name_pattern ' = ' time_pattern];
        capture_times = regexp(file_md, expr, 'names');

        % convert both time from start and time from last to seconds
        F = 'hh:mm:ss.SSSS';
        time_from_last = cellfun(@(X) ...
            seconds(duration(X(strcmp({X.name},'Time_From_Last')).time, ...
            'InputFormat', F, 'Format', F)), capture_times);
        time_from_start = cellfun(@(X) ...
            seconds(duration(X(strcmp({X.name},'Time_From_Start')).time, ...
            'InputFormat', F, 'Format', F)), capture_times);

        % Store info for file
        frame_info(curr_im_idx).frame_num(:) = 1:length(file_info);
        frame_info(curr_im_idx).time_from_last(:) = time_from_last;
        frame_info(curr_im_idx).time_from_start(:) = time_from_start;
        frame_info(curr_im_idx).timestamp.Second = frame_info(curr_im_idx).timestamp.Second + time_from_start;
    end

end

%% Get illumination color for each frame
% Assume: blue/violet alternating, with blue starting whenever there is a
% >2s gap (= new recording, which starts on blue)

switch im_filetype

    case 'tif'

        % Get total number of frames
        n_frames = sum(cellfun(@length,{frame_info.frame_num}));

        % Find recording boundaries (EITHER: start button was pressed and time
        % frome last frame is zero, OR: long time between frames)
        recording_boundary_thresh = 2; % seconds between frames to define recording
        recording_start_frame_idx = [find( ...
            [frame_info.time_from_last] == 0 | ...
            [frame_info.time_from_last] >= recording_boundary_thresh)];

        % Get recording for each frame (tack zero to start frame to ensure
        % interpolation even if only one recording)
        im_rec_idx = mat2cell( ....
            interp1([recording_start_frame_idx,0], ...
            1:(length(recording_start_frame_idx)+1), ...
            1:n_frames,'previous','extrap'), ...
            1,cellfun(@length,{frame_info.frame_num}));
        [frame_info.rec_idx] = im_rec_idx{:};

        % Get illumination color of frame (alternate starting at each recording)
        n_colors = 2;
        im_frame_color = mat2cell( ...
            1+mod((1:n_frames) - ...
            interp1(recording_start_frame_idx,recording_start_frame_idx,...
            1:n_frames,'previous','extrap'),n_colors), ...
            1,cellfun(@length,{frame_info.frame_num}));
        [frame_info.color] = im_frame_color{:};

    case 'dcimg'
        
        % DCIMG: requires 'n_widefield_frames' at the moment
        
        % Get number of frames across recordings
        im_file_nframes = nan(length(im_files),1);
        for curr_im_idx = 1:length(im_files)
            dcimg_fid = plab.wf.dcimgmex('open', im_files{curr_im_idx});
            im_file_nframes(curr_im_idx) = plab.wf.dcimgmex( 'getparam', dcimg_fid, 'NUMBEROF_FRAME' );
            plab.wf.dcimgmex('close', dcimg_fid)
        end

        %%%%%%%%%%%%%%% VERY TEMPORARY
        if sum(n_frames_rec) > sum(im_file_nframes)
            n_frames_rec = im_file_nframes;
            warning('Widefield preprocessing: more frames timelite than image, using image frames')
        elseif sum(n_frames_rec) < sum(im_file_nframes)
            % assume frames were cut off the first recording
            n_frames_rec(1) = n_frames_rec(1) + ...
                (sum(im_file_nframes) - sum(n_frames_rec));
            warning('Widefield preprocessing: more frames image than timelite, adding frames to first recording')
        end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        % Set recording start frames from input
        recording_start_frame_idx = [1;n_frames_rec(1:end-1)+1];

        % Get frame color
        frame_info = struct('frame_num',cell(length(im_file_nframes),1));
        frame_num = cellfun(@(x) 1:x,num2cell(im_file_nframes),'uni',false);
        [frame_info.frame_num] = frame_num{:};

        n_frames = sum(n_frames_rec);
        n_colors = 2;
        im_frame_color = mat2cell( ...
            1+mod((1:n_frames) - ...
            interp1(recording_start_frame_idx,recording_start_frame_idx,...
            1:n_frames,'previous','extrap'),n_colors), ...
            1,cellfun(@length,{frame_info.frame_num}));
        [frame_info.color] = im_frame_color{:};

        % Get recording for each frame (input to function)
        im_rec_idx = mat2cell(cell2mat(cellfun(@(x,idx) idx*ones(1,x), ...
            num2cell(n_frames_rec)',num2cell(1:length(n_frames_rec)), ...
            'uni',false)),1,im_file_nframes);
        [frame_info.rec_idx] = im_rec_idx{:};

end

% If number of frames/recording is supplied, check that it matches total
if n_frames ~= sum(n_frames_rec)
    error('Widefield preprocessing: different total frames found vs given per recording')
end



%% Get image size

switch im_filetype

    case 'tif'
        im_info = imfinfo(im_files{1});
        im_size = [im_info(1).Height,im_info(1).Width];
    case 'dcimg'
        dcimg_fid = plab.wf.dcimgmex('open', im_files{1});
        im_width = plab.wf.dcimgmex( 'getparam', dcimg_fid, 'IMAGE_WIDTH' );
        im_height = plab.wf.dcimgmex( 'getparam', dcimg_fid, 'IMAGE_HEIGHT' );
        im_size = [im_height,im_width];
        plab.wf.dcimgmex('close', dcimg_fid)
end

%% Create moving- and total-average images
% (moving average is used to create SVD spatial components)

% Set moving average number of frames
n_frame_avg = 15;

if verbose; disp('Building image moving average by color...'); end

switch im_filetype

    case 'tif'
        % TIFFs: load in each file and separate

        % Loop through images, cumulatively build averages by illumination color
        im_avg = zeros(im_size(1),im_size(2),n_colors);
        im_mov_avg = cell(length(im_files),n_colors);

        for curr_im_idx = 1:length(im_files)

            curr_im_fn = im_files{curr_im_idx};

            % Load in full tiff
            im = single(tiffreadVolume(curr_im_fn));

            % Loop through illumination colors
            for curr_color = 1:n_colors
                % Get color index for frames in current image
                curr_frame_color_idx = frame_info(curr_im_idx).color == curr_color;

                % Cumulatively add average image
                curr_color_partial = ...
                    sum(im(:,:,curr_frame_color_idx)./sum([frame_info.color] == curr_color),3);
                im_avg(:,:,curr_color) = im_avg(:,:,curr_color) + ...
                    curr_color_partial;

                % Get moving average (truncate based on moving avg modulus)
                curr_n_frames = sum(curr_frame_color_idx);
                curr_frame_avg_idx = find(curr_frame_color_idx, ...
                    curr_n_frames - mod(curr_n_frames,n_frame_avg));
                im_mov_avg{curr_im_idx,curr_color} = ...
                    permute(mean(reshape(im(:,:,curr_frame_avg_idx), ...
                    size(im,1),size(im,2),n_frame_avg,[]),3),[1,2,4,3]);
            end
        end

    case 'dcimg'
        % DCIMG: Load each file in chunks 
        % (index as cumulative chunks across files)
        frame_chunk_n = n_frame_avg*500; % emprical: 1000 hits out of memory > 12 chunks
        frame_chunks_file = cellfun(@(x) ceil((1:x)/frame_chunk_n), ...
            num2cell(im_file_nframes),'uni',false);
        frame_chunks = cellfun(@(chunk,cumulative_offset) ...
            chunk+cumulative_offset,frame_chunks_file, ...
            num2cell([0;cellfun(@max,frame_chunks_file(1:end-1))]),'uni',false);

        n_frame_chunks = max(frame_chunks{end});

        im_avg = zeros(im_size(1),im_size(2),n_colors);
        im_mov_avg = cell(n_frame_chunks,n_colors);

        for curr_im_idx = 1:length(im_files)
            curr_im_fn = im_files{curr_im_idx};

            % Open file for reading
            dcimg_fid = plab.wf.dcimgmex('open', im_files{curr_im_idx});

            for curr_frame_chunk = unique(frame_chunks{curr_im_idx})
                curr_load_frames = find(frame_chunks{curr_im_idx} == curr_frame_chunk);
                im = zeros(im_size(1),im_size(2),length(curr_load_frames),'single');

                for curr_load_frame_idx = 1:length(curr_load_frames)
                    curr_frame = curr_load_frames(curr_load_frame_idx);
                    im(:,:,curr_load_frame_idx) = ...
                        plab.wf.dcimgmex('readframe', dcimg_fid, curr_frame-1)';
                end

                % Loop through illumination colors
                for curr_color = 1:n_colors
                    % Get color index forifif frames in current image
                    curr_frame_color_idx = frame_info(curr_im_idx).color(curr_load_frames) == curr_color;

                    % Cumulatively add average image
                    curr_color_partial = ...
                        sum(im(:,:,curr_frame_color_idx)./sum([frame_info.color] == curr_color),3);
                    im_avg(:,:,curr_color) = im_avg(:,:,curr_color) + ...
                        curr_color_partial;

                    % Get moving average (truncate based on moving avg modulus)
                    curr_n_frames = sum(curr_frame_color_idx);
                    if curr_n_frames < n_frame_avg
                        continue
                    end

                    curr_frame_avg_idx = find(curr_frame_color_idx, ...
                        curr_n_frames - mod(curr_n_frames,n_frame_avg));
                    im_mov_avg{curr_frame_chunk,curr_color} = ...
                        permute(mean(reshape(im(:,:,curr_frame_avg_idx), ...
                        size(im,1),size(im,2),n_frame_avg,[]),3),[1,2,4,3]);
                end

                fprintf('Frame chunk: %d/%d\n', ...
                    curr_frame_chunk,max(unique(frame_chunks{curr_im_idx})));
            end

            % Close file
            plab.wf.dcimgmex('close', dcimg_fid)

        end
end


%% Do SVD on moving-average images
% (keep U and S, don't keep V since U will be applied to full dataset next)

if verbose; disp('Running SVD on moving average images by color...'); end

[U_full,~,~] = arrayfun(@(color) ...
    svd(reshape(cat(3,im_mov_avg{:,color}),prod(im_size),[]),'econ'), ...
    1:n_colors,'uni',false);

% Reshape U into pixels row x pixels column x components (only keep the
% maximum number of set components)
U = cellfun(@(x) reshape(x(:,1:min(size(x,2),max_components)), ...
    im_size(1),im_size(2),[]),U_full,'uni',false);

% Clear the full U's to save space
clear U_full


%% Apply spatial components (U's) from SVD to full data
% (note: spatial components are applied as U' * mean-subtracted data, so
% the resulting matrix is equivalent to S*V but just called 'V')

if verbose; disp('Applying SVD spatial components to full data...'); end

switch im_filetype

    case 'tif'
        V = cell(length(im_files),n_colors);
        for curr_im_idx = 1:length(im_files)

            curr_im_fn = fullfile(im_files,im_files(curr_im_idx).name);
            im = single(tiffreadVolume(curr_im_fn));

            % Loop through illumination colors
            for curr_color = 1:n_colors
                % Get color index for frames in current image
                curr_frame_color_idx = frame_info(curr_im_idx).color == curr_color;

                % Apply spatial components to mean-subtracted data
                V{curr_im_idx,curr_color} = ...
                    reshape(U{curr_color},[],size(U{curr_color},3))' * ...
                    (reshape(im(:,:,curr_frame_color_idx),[],sum(curr_frame_color_idx)) - ...
                    reshape(im_avg(:,:,curr_color),[],1));
            end
        end

    case 'dcimg'
        for curr_im_idx = 1:length(im_files)

            % Open file for reading
            dcimg_fid = plab.wf.dcimgmex('open', im_files{curr_im_idx});

            for curr_frame_chunk = unique(frame_chunks{curr_im_idx})
                curr_load_frames = find(frame_chunks{curr_im_idx} == curr_frame_chunk);
                im = zeros(im_size(1),im_size(2),length(curr_load_frames),'single');

                for curr_load_frame_idx = 1:length(curr_load_frames)
                    curr_frame = curr_load_frames(curr_load_frame_idx);
                    im(:,:,curr_load_frame_idx) = ...
                        plab.wf.dcimgmex('readframe', dcimg_fid, curr_frame-1)';
                end

                % Loop through illumination colors
                for curr_color = 1:n_colors
                    % Get color index for frames in current image
                    curr_frame_color_idx = frame_info(curr_im_idx).color(curr_load_frames) == curr_color;

                    % Apply spatial components to mean-subtracted data
                    V{curr_frame_chunk,curr_color} = ...
                        reshape(U{curr_color},[],size(U{curr_color},3))' * ...
                        (reshape(im(:,:,curr_frame_color_idx),[],sum(curr_frame_color_idx)) - ...
                        reshape(im_avg(:,:,curr_color),[],1));
                end

                fprintf('Frame chunk: %d/%d\n', ...
                    curr_frame_chunk,max(unique(frame_chunks{curr_im_idx})));
            end

            % Close file
            plab.wf.dcimgmex('close', dcimg_fid)
            
        end

end

%% Split V's by recording (instead of by file)

if verbose; disp('Splitting SVD temporal components by recording...');end

if ~exist('n_frames_rec','var') || isempty(n_frames_rec)
    % If number of frames by recordings not provided, get by timestamps

    % Store V's as recordings x color
    Vrec = cell(length(recording_start_frame_idx),n_colors);

    frame_color_cat = horzcat(frame_info.color)';
    frame_rec_idx_cat = horzcat(frame_info.rec_idx)';
    for curr_color = 1:n_colors

        % Split concatenated V by recording index
        curr_V_cat = horzcat(V{:,curr_color});
        Vrec(:,curr_color) = ...
            mat2cell(curr_V_cat,size(curr_V_cat,1), ...
            accumarray(frame_rec_idx_cat(frame_color_cat == curr_color),1));

    end

else
    % If number of frames by recordings provided, use those

    % Store V's as recordings x color
    Vrec = cell(length(n_frames_rec),n_colors);

    frame_color_cat = horzcat(frame_info.color)';
    frame_rec_idx_cat = horzcat(frame_info.rec_idx)';
    for curr_color = 1:n_colors

        % Split concatenated V by recording index
        curr_V_cat = horzcat(V{:,curr_color});
        Vrec(:,curr_color) = ...
            mat2cell(curr_V_cat,size(curr_V_cat,1), ...
            accumarray(frame_rec_idx_cat(frame_color_cat == curr_color),1));

    end

end

if verbose; disp('Finished SVD.'); end


catch me
    warning(me.identifier,'WF preprocessing debug: %s',me.message);
    keyboard

end














































